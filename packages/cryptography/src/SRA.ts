// Implementation of SRA (Shamir-Rivest-Adleman) commutative encryption
// algorithm. This is not RSA - same authors, different algorithm.
import { BigIntMath } from "./bigIntMath";

// SRA key pair consists of an agreed-upon large prime and enc and dec
// primes derived from it (private) and used to encrypt/decrypt
export type SRAKeyPair = {
    prime: bigint;
    enc: bigint;
    dec: bigint;
};

// SRA implementation
export namespace SRA {
    // Generate an SRAKeyPair given a large prime.
    // enc and dec are generated by trial and error. We can configure the size
    // in bytes for this. Default is 128 byte (1024 bits).
    // TODO: we should be able to infer size based on the provided large prime.
    export function generateKeyPair(
        largePrime: bigint,
        size: number = 128
    ): SRAKeyPair {
        const phi = largePrime - BigInt(1);
        let enc = BigInt(0);

        // Trial and error
        for (;;) {
            // Generate a large prime
            enc = BigIntMath.randPrime(size);

            // Stop when generated prime and passed in prime - 1 are coprime
            if (BigIntMath.gcd(enc, phi) === BigInt(1)) {
                break;
            }
        }

        // enc is our encryption key, now let's find dec as the mod inverse of enc
        let dec = BigIntMath.modInverse(enc, phi);

        return {
            prime: largePrime,
            enc: enc,
            dec: dec,
        };
    }

    // Encrypts an object
    export function encrypt<T>(obj: T, kp: SRAKeyPair): string {
        return encryptString(JSON.stringify(obj), kp);
    }

    // Decrypts an object
    export function decrypt<T>(cypherText: string, kp: SRAKeyPair): T {
        return JSON.parse(decryptString(cypherText, kp));
    }

    // Encrypts a string
    export function encryptString(clearText: string, kp: SRAKeyPair): string {
        // Convert string to a bigint, encrypt that, then convert back
        return bigIntToString(encryptInt(stringToBigInt(clearText), kp));
    }

    // Decrypts a string
    export function decryptString(cypherText: string, kp: SRAKeyPair): string {
        // Convert string to a bigint, decrypt that, then convert back
        return bigIntToString(decryptInt(stringToBigInt(cypherText), kp));
    }

    // Encrypts a bigint n
    function encryptInt(n: bigint, kp: SRAKeyPair) {
        // Encryption consists of raising n to enc modulo agreed-upon prime
        return BigIntMath.exp(n, kp.enc, kp.prime);
    }

    // Decrypt a bigint n
    function decryptInt(n: bigint, kp: SRAKeyPair) {
        // Decryption consists of raising n to dec modulo agreed-upon prime
        return BigIntMath.exp(n, kp.dec, kp.prime);
    }

    // Converts a string into bigint - shouldn't be exported but we need this
    // since BigInt is not serializable
    export function stringToBigInt(str: string): bigint {
        let result = BigInt(0);

        for (const c of str) {
            // Making an assumption here that we're dealing with char codes under 256
            // to keep things simple. Might need to revisit if we want to generalize.
            if (c.charCodeAt(0) > 255) {
                throw Error(`Unexpected char code ${c.charCodeAt(0)} for ${c}`);
            }

            // Build a bigint out of all the char codes in the string
            result = result * BigInt(256) + BigInt(c.charCodeAt(0));
        }

        return result;
    }

    // Converts a bigint into a string - shouldn't be exported but we need this
    // since BigInt is not serializable
    export function bigIntToString(n: bigint): string {
        let result = "";
        let m = BigInt(0);

        // Inverse of stringToBigInt - decompose n to char codes
        while (n > 0) {
            [n, m] = [n / BigInt(256), n % BigInt(256)];
            result = String.fromCharCode(Number(m)) + result;
        }

        return result;
    }
}
